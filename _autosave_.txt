@name Orbiter
@inputs 
@outputs A B C X Ax Y Ay Z M D H S O:entity Red Green Blue Ma U V W B2 B3
@persist 
@trigger 

#runOnTick(1)

#if (A > 80) {A = 1}
#A+=5

# Size of holos
S = 0.5

# Holo count
A = 5

# Second holo count
B = A + 1
B2 = B + 1
B3 = B2 + 1


if (first()) {  

    # Executes all but if(first()) with a default latency of 15ms, see documentation for more informtaion
    runOnTick(1)
    
    for(I = 1, A) {
        
        Red = 0
        Green = random(255)+100
        Blue = random(150)+100
        
        # First holo - Orbit on player position
        holoCreate(I)
        
        holoModel(I, "icosphere3")
        holoScale(I, vec(S, S, S))
        holoAlpha(I, 250)
        holoColor(I, vec(0, 0, 0))
        
        holoEntity(I):setTrails(8, 0, 0.5, "trails/physbeam", vec(Red, Green, Blue), 255)
        
        # Second holo - Orbit on first holo
        holoCreate(I+B)
        
        holoModel(I+B, "torus3")
        holoScale(I+B, vec(S-S/2, S-S/2, S-S/2))
        holoAlpha(I+B, 60)
        holoColor(I+B, vec(Red, Green, Blue))
        
        holoEntity(I+B):setTrails(2, 0, 0.4, "trails/physbeam", vec(255, 0, 0), 255)

        # Third holo - Orbit on first holo
        holoCreate(I+B2)
        
        holoModel(I+B2, "torus3")
        holoScale(I+B2, vec(S-S/2, S-S/2, S-S/2))
        holoAlpha(I+B2, 60)
        holoColor(I+B2, vec(Red, Green, Blue))
        
        holoEntity(I+B2):setTrails(2, 0, 0.4, "trails/physbeam", vec(0, Green, 0), 255)

        # Fourth holo - Orbit on first holo
        holoCreate(I+B3)
        
        holoModel(I+B3, "torus3")
        holoScale(I+B3, vec(S-S/2, S-S/2, S-S/2))
        holoAlpha(I+B3, 60)
        holoColor(I+B3, vec(Red, Green, Blue))
        
        holoEntity(I+B):setTrails(2, 0, 0.4, "trails/physbeam", vec(0, 0, Blue), 255)

        
        
    }

    O = owner()
    X = 0
    Y = 0
    
    # Speed & Self-rotation speed
    M = 1
    Ma = 1
    
    # Distance
    D = 50
    
    # Height
    H = 5
    
}

# cos() is for X 
# sin() is for Y

function void spinHolo() {

    for (I = 1, A) {
        
        holoAng(I+B, ang(vec(Ax+I*10, Ay+I*500, Ax+Ay+I*500)))
        holoAng(I+B2, ang(vec(Ax+I*10, Ay+I*500, Ax+Ay+I*500)))
        holoAng(I+B3, ang(vec(Ax+I*10, Ay+I*500, Ax+Ay+I*500)))
            
    }

}

function void rotate() {
    
    for (I = 1, A) {
    
        holoPos(I, O:pos() + vec( cos(X + I*500)*D, sin(Y + I*500)*D, H + I*10 ))
        holoPos(I+B, holoEntity(I):pos() + vec( cos(U)*(D-45), sin(V)*(D-45), cos(W)*(D-45) ))
        holoPos(I+B2, holoEntity(I):pos() + vec( cos(U + I*120)*(D-45), sin(V + I*120)*(D-45), cos(W + I*120)*(D-45) ))
        holoPos(I+B3, holoEntity(I):pos() + vec( cos(U + I*240)*(D-45), sin(V + I*240)*(D-45), cos(W + I*240)*(D-45) ))
        spinHolo()
    
    }
    
}

if ( O:inNoclip() & !changed(O:pos()) ) {
    
    for (I = 1, A) {
    
        holoPos(I, O:pos() + vec(cos(X + I*500)*D, sin(Y + I*500)*D, H+20 + I*10))
        holoPos(I+B, holoEntity(I):pos() + vec(0, 0, 0))
        holoPos(I+B2, holoEntity(I):pos() + vec(0, 0, 0))
        holoPos(I+B3, holoEntity(I):pos() + vec(0, 0, 0))
        spinHolo()
    
    }
    
}

elseif (!changed(O:pos())) {

    rotate()

}

elseif (O:isCrouch() & !changed(O:pos())) {
    
    rotate()
    
}

else {

    for (I = 1, A) {
        
        holoPos(I, O:pos() + vec( cos(X + I*500)*(D-40), -30, 70 + sin(Y + I*500)*(D-40) ):rotate(ang(0, O:angles():yaw()+-90, 0)))
        holoPos(I+B, holoEntity(I):pos() + vec(0, 0, 0):rotate(ang(0, O:angles():yaw()+-90, 0)))
        holoPos(I+B2, holoEntity(I):pos() + vec(0, 0, 0):rotate(ang(0, O:angles():yaw()+-90, 0)))
        holoPos(I+B3, holoEntity(I):pos() + vec(0, 0, 0):rotate(ang(0, O:angles():yaw()+-90, 0)))
        spinHolo()
        #holoPos(I, O:pos() + vec(cos(X + I*500)*D, sin(Y + I*500)*D, H+20 + I*10))
        
    }
    
}

# Value increments for rotation based on M which is the distance it goes
# So in other words speed, also Ma is ang speed
U+=M+5
V+=M+5
W+=M+5

X+=M
Y+=M
Ax+=Ma
Ay+=Ma
